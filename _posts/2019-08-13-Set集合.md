---
layout: post
title: "Set集合"
date: 2019-08-13
tag: 集合
---
### 概念

**集合与数组的对比**

> 集合：就是一个存储数据的容器。
> 集合与数组一样，也是一个容器，与数组的区别：
> 1. 数组长度固定，集合的长度不固定。
> 2. 数组可以存储`基本类型`和`引用类型`，集合中存储的元素类型只能是`引用类型`(自动装箱和拆箱)。

### 集合的框架结构

> * Collection集合的框架结构
> ![Collection集合](/images/Collection集合.png)
> * Map集合的框架结构
> ![Map集合](/images/Map集合.png)

### 1. Collecation集合

> Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。
> List派系:可以重复、有序
> Set派系:不能重复、无序
> * 代码就不贴出了。循环遍历可以用增强for和迭代器

### set集合

> 特性:
> - 无序存储，不可以存储相同的元素，不能通过下标访问
> 遍历:
> - 通过增强for
> - 或使用迭代器Iterator

### HashSet集合

> 特性:
> - 此类实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。

> Hash:
> - 哈希——实际含义散列,就是一种算法，把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。

> 存储结构：
> - 哈希表:数组+链表,既有数组的优点也有链表的优点。（jdk1.7之前 数组+链表，jdk1.8 数组+链表+红黑树）
> - 基于 HashMap 实现的，底层采用 HashMap 来保存元素

> 存储特点：
> - 相对`无序存储`，不可以存储相同元素（排重），通过`哈希表`实现的集合

> 重写hashCode() (可以实现排重效果)
> - hashCode()是Object中的方法，每个对象的hashCode值是唯一的，所以可以理解成hashCode值表示这个对象在内存中的位置
> - HashSet集合排重时，需要判断两个对象是否相同，对象相同的判断可以通过hashCode值判断，所以需要重写hashCode()方法

> 重写equals()(重点)
> - equals()方法是Object类中的方法，表示比较两个对象是否相等，若不重写相当于比较对象的地址
> - 所以我们可以尝试重写equals方法，检查是否排重

> * HashSet的重复依据:`hashCode`和`equals`需要同时重写hashCode和equals方法，实现排重。

### LinkedHashSet集合

> LinkedHashSet类是具有可预知迭代顺序(相对有序)的Set接口的`哈希表`和`链接列表`实现。是HashSet的子类。

> 存储特点:
> - 有序存储，不可以存储相同元素（排重），通过链表实现的集合的有序。

### TreeSet集合(重要)

> TreeSet集合是可以给元素进行`重新排序`的一个Set接口的实现。使用元素的`自然顺序`对元素进行排序，或者根据创建 set 时提供的

> 存储特点：
> - 无序存储，排重，通过`红黑树`实现的集合，可以给元素进行`重新排序`

**SortedSet接口**

> TreeSet除了实现了Set接口外，还实现了SortedSet接口
> 它的方法查API吧

**TreeSet集合的元素排序**

> 元素所属的类需要实现java.lang.Comparable接口，并重写compareTo方法。
> compareTo方法除了可以进行排序外，还有排重的功能，但是必须在compareTo方法中对类中所有的属性值都进行判断，否则不比较那个属性，排重就会忽略哪个属性

> * 演示代码:
> ```java
> @Override
> public int compareTo(Student o) {
>       int n1=this.name.compareTo(o.name);
>       int n2=this.age-o.age;
>       return n1==0?n2:n1;
> }
> ```

> - 或者`定制排序`，元素需要通过`java.util.Comparator接口`（比较器）中的`compare方法`进行比较大小，并排序。
> - compare方法除了可以进行排序外，还有排重的功能，但是必须在compare方法中对类中所有的属性值都进行判断，否则不比较那个属性，排重就会忽略哪个属性
> - TreeSet集合中的无参数构造方法默认使用自然排序的方式对元素进行排序，使用TreeSet集合的定制排序时，创建集合对象`不可以直接使用无参数构造方法`，需要使用`传入一个Comparator比较器的构造方法`创建集合对象。

> * 演示代码:
> ```java
>TreeSet<String> treeSet=new TreeSet<String>(new Comparator<String>() {
> @Override
> public int compare(Student o1, Student o2) {
>       int n1=o1.getAge()-o2.getAge();
>       int n2=o1.getName().compareTo(o2.getName());
>       return n1==0?n2:n1;
> }
>}
> ```

<br>

转载请注明：[Memory的博客](https://www.shendonghai.com) » [点击阅读原文](https://www.shendonghai.com/2018/04/Hibernate/) 